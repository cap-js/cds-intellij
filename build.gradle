import org.jetbrains.intellij.platform.gradle.TestFrameworkType
import org.jetbrains.intellij.platform.gradle.IntelliJPlatformType

plugins {
    id 'java'
    id 'org.jetbrains.intellij.platform' version '2.1.0'
}

def hasLocalProperties = provider {
    return file('local.properties').exists()
}

if (hasLocalProperties.get()) {
    def props = new Properties()
    file('local.properties').withInputStream { stream ->
        props.load(stream)
    }
    for (prop in props) {
        project.ext[prop.key] = prop.value
    }
}

repositories {
    mavenCentral()

    intellijPlatform {
        defaultRepositories()
        jetbrainsRuntime()
    }
}

dependencies {
    implementation 'org.jetbrains:annotations:24.1.0'
    implementation 'org.json:json:20240303'
    implementation 'org.apache.maven:maven-artifact:3.9.9'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.11.0'
    testCompileOnly 'junit:junit:4.13.2'

    intellijPlatform {
        String type = project.findProperty('platformType')
        String version = project.findProperty('platformVersion')
        create(type, version)

        bundledPlugins(['com.intellij.java', 'org.jetbrains.plugins.textmate'])

        instrumentationTools()
        pluginVerifier()
        testFramework(TestFrameworkType.Platform.INSTANCE)
        testFramework(TestFrameworkType.Plugin.Java.INSTANCE)
    }
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(project.findProperty('javaVersion') as String)
    }
}

intellijPlatform {
    buildSearchableOptions = false
    autoReload = /* set to true to enable plugin reload on FS changes inside plugin */ false
    pluginVerification {
        ides {
            String type = project.findProperty('platformType')
            String version = project.findProperty('platformVersion')
            ide(type, version)
        }
    }
}

intellijPlatformTesting.runIde {
    runWebStorm {
        type = IntelliJPlatformType.WebStorm
        if (project.hasProperty('local.ideDir')) {
            localPath = project.file(project.findProperty('local.ideDir'))
        }
        task {
            dependsOn 'copyLspToRunWebStorm', 'syncSandboxIdeConf'
        }
    }
}

tasks {
    wrapper {
        gradleVersion = project.findProperty('gradleVersion')
    }

    patchPluginXml {
        version = project.findProperty('pluginVersion')
        sinceBuild = project.findProperty('pluginSinceBuild')
        untilBuild = project.findProperty('pluginUntilBuild')
    }

    buildPlugin {
        dependsOn 'copyLsp'
        archiveFileName = project.findProperty('archiveName')
    }

    verifyPlugin {
        dependsOn 'copyLsp'
    }

    test {
        dependsOn 'copyLspToInstrumented'
    }

    publishPlugin {
        token.set(System.getenv("JB_TOKEN"))
    }

    clean {
        doFirst {
            delete './lsp/node_modules'
        }
    }
}

tasks.register('syncSandboxIdeConf', Copy) {
    onlyIf { hasLocalProperties.get() }
    into "${tasks.named('prepareSandbox_runWebStorm').map{it.defaultDestinationDirectory}.get().get()}/../config"
    into('keymaps') {
        from "${project.findProperty('local.ideConfDir')}/keymaps"
    }
    into('options') {
        from "${project.findProperty('local.ideConfDir')}/options/ide.general.xml"
    }
    into('options') {
        from "${project.findProperty('local.ideConfDir')}/options/laf.xml"
    }
    into('options') {
        from "${project.findProperty('local.ideConfDir')}/options/trusted-paths.xml"
    }
    into('options/linux') {
        from "${project.findProperty('local.ideConfDir')}/options/linux"
    }
    into('options/mac') {
        from "${project.findProperty('local.ideConfDir')}/options/mac"
    }
    into('options/windows') {
        from "${project.findProperty('local.ideConfDir')}/options/windows"
    }
}

tasks.register('rmLspNodeModules', Delete) {
    def cdsLspFromTar = provider {
        return project.findProperty('local.cdsLspFromTar') == 'true'
    }
    onlyIf { cdsLspFromTar.get() }
    mustRunAfter prepareSandbox, prepareSandbox_runWebStorm
    delete 'lsp/node_modules'
}

tasks.register('installLsp', Exec) {
    def noNodeModules = provider {
        // re-evaluated on each gradle run
        return !file('lsp/node_modules/@sap/cds-lsp').exists() || project.findProperty('local.cdsLspFromTar') == 'true'
    }
    onlyIf { noNodeModules.get() }
    dependsOn rmLspNodeModules
    workingDir './lsp'
    if (System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')) {
        commandLine 'cmd', '/c', 'npm', 'install', '--no-package-lock'
    } else {
        commandLine 'sh', '-c', 'npm install --no-package-lock'
    }
}

// TODO copy before install

tasks.register('copyLsp', Copy) {
    dependsOn installLsp
    mustRunAfter 'buildSearchableOptions'
    from './lsp'
    into "${tasks.named('prepareSandbox').map{it.pluginDirectory}.get().get()}/lib/cds-lsp"
}

tasks.register('copyLspToRunWebStorm', Copy) {
    dependsOn installLsp
    mustRunAfter 'buildSearchableOptions'
    from './lsp'
    into "${tasks.named('prepareSandbox_runWebStorm').map{it.pluginDirectory}.get().get()}/lib/cds-lsp"
}

tasks.register('copyLspToInstrumented', Copy) {
    dependsOn installLsp
    from './lsp'
    into './build/instrumented/cds-lsp'
}
